A mark-region collector is being developed for SBCL. The intention is
that avoiding compaction/copying should allow for better performance,
and should make implementing parallel and concurrent collection easier
(but neither has been implemented just yet).

Heap layout
-----------

The collector retains the page-orientation of gencgc, but introduces a
second layer of "lines" as used in the Immix collector for small
objects. Line metadata, including the generation number and a mark
bit, is stored in a "bytemap". Memory used for small objects is
reclaimed at the line level, rather than the page level, in order to
reclaim most memory without having to move objects. Each line is
assigned its own generation, to allow memory from older generations to
be reused for newer generations. Line size is fixed to 16 words
(i.e. 8 possible places an object could be allocated) to make bitwise
operations simpler.

The starts of objects are recorded in an allocation bitmap. Lisp uses
a BTS instruction; as threads still claim whole pages at a time, there
is no need for writing to the bitmap to be atomic. Ambiguous pointers
can be checked by consulting the bitmap; it is also possible to scan
the bitmap if support for interior pointers is desired.

Marking
-------

The collector employs a classic tri-color mark-sweep algorithm. A mark
bitmap stores mark bits for objects, storing if an object is white, or
if an object is grey or black. Lines are also assigned mark bits,
which represent if the line can be reclaimed or not, and all lines
intersecting an object are marked when an object is marked. Grey
objects are stored on a mark stack, represented as a linked list of
"grey packets", each packet containing a vector of pointers to
trace. The collector reads off pointers to trace from an "input
packet", and writes out more pointers to trace from an "output
packet". Prefetching the pointers in the input packet is somewhat
effective.

Marking can be made parallel by giving each collector thread its own
input and output packets, and requiring the shading of an object to be
an atomic operation. A thread does not mark an object if it fails to
set the mark bit atomically, as another thread marked it in the
meanwhile, and will proceed in marking the object. (We almost could go
without atomicity, since marking and tracing are idempotent, but
writing the bitmap must be atomic, or data races could cause objects
to become unmarked.)

Sweeping
--------

Sweeping is complicated by the use of generations, and by the rather
odd heap layout. If a full collection was used, it would suffice to
copy the mark bitmap to the allocation bitmap, in order to sweep the
allocation bitmap, and to free every line that was not
marked. However, the use of generations requires that we retain
allocations and line usage for older generations. Conceptually, now,
we have to "blend" the allocation and mark bitmaps, based on the
values stored in the line bytemap.

This blending operation is made rather simple, as every byte of the
allocation bitmap corresponds to a byte of the line bytemap, due to
our definition of the line size. We copy a byte of the mark bitmap to
the allocation bitmap only when the corresponding line is in the
generation being collected, preserving allocation bits for older
objects. We unmark each line that is marked and in the generation
being collected, and free each line that is unmarked and in the
generation being collected, preserving older lines.

Computing occupancy of each page, each generation, and the entire heap
is also tricky. The current approach, which could be improved upon, is
to count the number of dead lines on each page, and then decrement the
occupancy of the page, the heap, and the generation being collected by
the number of dead bytes found. Another approach would be to count the
number of live lines on each page, which requires the same amount of
work, and to also count the number of live lines in the generation
being collected. In either case, it is only necessary to recompute
occupancy for the generation being collected, as the collector
performs no actions that would cause the occupancy of any other
generation to change.

All the sweeping operations can be (automatically) vectorised, which
improves performance substantially.

Scavenging
----------

In a generational collector, it is also necessary to trace certain
"remembered" objects in older generations, which contain pointers to
new objects which must be preserved. SBCL records pointer writes using
a card map, and a subset of these writes will be to older objects, and
a subset of those writes will be storing pointers to new objects. The
collector scans every card to find pointers from old objects to new
objects, and mark the new objects. Similar to sweeping, it is possible
to use blending to compute a bitmap of only old objects, by only
retaining bytes from the allocation bitmap that reside on older lines.

The write barrier for mark-region collection has been extended for
simple vectors. Unlike the barrier for the copying collector, which
dirties only the card the slot is on, the write barrier dirties both the
start and the dirty card. The intent is that scavenging pages
containing small objects doesn't have to bother with dirty cards
appearing in the middle of objects, but scavenging pages containing
a single (large) object can pick just the lines that need to be dirtied.
The drawbacks are, of course, that now two lines are dirtied rather
than one, effectively doubling write barrier overhead, and the
first line of every large simple vector has to be scavenged for no
reason (but that is preferable to the loss of precision with larger
cards, to be fair).

The C shore
-----------

The heap layout breaks many things which one might have taken for
granted in the heap layout used by gencgc. For example, objects are no
longer really contiguous in the heap, and trying to walk a page with
something like

  for (lispobj *where = start; where < end; where += object_size(where))
    ...

is not going to work. Instead, there is a shim in walk-heap.h which
allows for walking a non-contiguous heap correctly; this must also be
called to initialise `where` so that the first object in the range is
found correctly. Such a loop may instead be written like

  for (lispobj *where = next_object(start, 0, end); where;
       where = next_object(where, object_size, end))
    ...

which admittedly is less pretty. next_object just computes (where + size)
and checks bounds when using the copying collector, and so using it is
portable across both collectors.

Another less portable thing is the value of `end` in the supposed loop.
With the copying collector, this is indeed
`page_address(page) + page_words_used(page)`, but when using the
mark-region collector, all of the page must be considered, and so the
end should be `page_address(page + 1)`. Similarly, page_limit may be
used now to find the end of a page, and walk_generation will also
do what you want.

Running the write barrier manually in C is also likely to be wrong;
we now _need_ to dirty the card on the start of the object, and not
any card intersecting the object, when the object is small. We need
to dirty both the start and the slot when the object is large.

Useful references
-----------------
Immix: https://www.cs.utexas.edu/users/speedway/DaCapo/papers/immix-pldi-2008.pdf
Grey packets: https://dl.acm.org/doi/10.1145/1108970.1108972
Sticky marks in generational collection: https://dl.acm.org/doi/pdf/10.1145/96709.96735